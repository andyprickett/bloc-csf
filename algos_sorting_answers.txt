Exercises

1. Write pseudocode for bubble sort.
>
FUNCTION bubbleSort(collection)
  REPEAT
    SET swapped to false
    FOR each item in the collection
      IF currentItem > nextItem THEN
        SET tempItem to currentItem
        SET currentItem to nextItem
        SET nextItem to tempItem
        SET swapped to true
      END IF
    END FOR
  UNTIL swapped is false
  RETURN collection
END FUNCTION

2. Write pseudocode for quicksort.
>
First, swapper:

FUNCTION swapper(collection, firstIndex, secondIndex)
  SET temp to collection element at firstIndex
  SET collection element at firstIndex to collection element at secondIndex
  SET collection element at secondIndex to temp
END FUNCION

Second, partion:

FUNCTION partition(collection, lowIndex, highIndex)
  SET partitionIndex to lowIndex
  SET iterationIndex to lowIndex
  WHILE iterationIndex < highIndex
    IF collection element at iterationIndex <= collection element at highIndex THEN
      CALL swapper with collection, iterationIndex, and partitionIndex
      INCREMENT partitionIndex by 1
    END IF
    INCREMENT iterationIndex by 1
  END WHILE
  CALL swapper with collection, partitionIndex, and highIndex
  RETURN partitionIndex
END FUNCTION

Third, quicksort:

FUNCTION quicksort(collection, lowIndex, highIndex)
  IF lowIndex < highIndex
    SET partitionIndex to (CALL partition with collection, lowIndex, highIndex RETURNING partitionIndex)
    CALL quicksort with collection, lowIndex, partitionIndex - 1
    CALL quicksort with collection, partitionIndex + 1, highIndex
END FUNCTION

3. We talked about time complexity in a previous checkpoint, and how to get an idea of the efficiency of an algorithm. After looking at the pseudocode for the above sorting methods, identify why merge sort and quick sort are much more efficient than the others. Walking through each algorithm with a few sample collections may help.
>
Simply, part of the solution for Merge and Quick sort involves recursion, so the problem is made smaller each time. While they still need to "assemble" things back in 'n'/linear time, those recursive calls are 'log n' (on average), so their 'n log n' big O is better performing than the other algorithms big O's of 'n^2'.

4. All of the sorts addressed in this checkpoint are known as comparison sorts. Research bucket sort and explain how it works. What is the ideal input for bucket sort?
>
Bucket sort distributes each item into one of n 'buckets' that has a sub-range of the maximum value range of the collection. Within each bucket, another distribution can occur (and another, and another...), or some other sorting process can occur, and then the buckets are concatenated. If the input values are evenly distributed across their total range, then this works well, and in O(n) time.
